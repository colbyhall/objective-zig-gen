const std = @import("std");
const Self = @This();

// Describes the location of an AST node within the source code.
pub const Loc = struct {
    offset: ?u32 = null, // Offset in the file where the node begins.
    file: []const u8 = &.{}, // Filename containing the node.
    line: ?u32 = null, // Line number where the node begins.
    presumedLine: ?u32 = null, // Line number after preprocessing.
    col: ?u32 = null, // Column number where the node begins.
    tokLen: ?u32 = null, // Length of the token represented by the node.
    includedFrom: ?*Loc = null, // Location of the include directive for this file.
    spellingLoc: ?*Loc = null, // Original location before macro expansion.
    expansionLoc: ?*Loc = null, // Location where the macro was expanded.
    isMacroArgExpansion: bool = false, // True if this is a macro argument expansion.
};

// Represents a range within the source code.
pub const Range = struct {
    begin: Loc = .{}, // Start location of the range.
    end: Loc = .{}, // End location of the range.
};

// Details about the type associated with an AST node.
pub const Type = struct {
    desugaredQualType: []const u8 = &.{}, // Fully desugared type as a string.
    qualType: []const u8, // Qualified type as a string.
    typeAliasDeclId: []const u8 = &.{}, // Identifier for a type alias declaration.
};
pub const Kind = enum {
    Unknown,

    // Declarations
    TranslationUnitDecl,
    TypedefDecl,
    ObjCInterfaceDecl,
    RecordDecl,
    FieldDecl,
    FunctionDecl,
    ParmVarDecl,
    VarDecl,
    EnumDecl,
    EnumConstantDecl,
    IndirectFieldDecl,
    ObjCMethodDecl,
    ObjCPropertyDecl,
    EmptyDecl,
    ObjCProtocolDecl,

    // Statements
    CompoundStmt,
    ReturnStmt,
    IfStmt,
    SwitchStmt,
    CaseStmt,
    DefaultStmt,
    BreakStmt,
    DeclStmt,
    GCCAsmStmt,

    // Expressions
    CStyleCastExpr,
    ParenExpr,
    BinaryOperator,
    ImplicitCastExpr,
    DeclRefExpr,
    IntegerLiteral,
    CallExpr,
    MemberExpr,
    ArraySubscriptExpr,
    ConditionalOperator,
    UnaryOperator,
    InitListExpr,
    UnaryExprOrTypeTraitExpr,
    CompoundAssignOperator,
    FloatingLiteral,
    CharacterLiteral,
    ObjCBoolLiteralExpr,
    ConstantExpr,
    ObjCMessageExpr,

    // Types
    BuiltinType,
    PointerType,
    ObjCObjectPointerType,
    ObjCObjectType,
    RecordType,
    ElaboratedType,
    TypedefType,
    ConstantArrayType,
    ParenType,
    FunctionProtoType,
    AttributedType,
    BlockPointerType,
    DecayedType,
    IncompleteArrayType,
    EnumType,
    QualType,
    ObjCInterfaceType,

    // Attributes
    BuiltinAttr,
    NoThrowAttr,
    ConstAttr,
    PackedAttr,
    AvailabilityAttr,
    AlwaysInlineAttr,
    ColdAttr,
    DisableTailCallsAttr,
    PureAttr,
    AvailableOnlyInDefaultEvalMethodAttr,
    ReturnsTwiceAttr,
    AsmLabelAttr,
    FormatAttr,
    DeprecatedAttr,
    FormatArgAttr,
    EnumExtensibilityAttr,
    CFAuditedTransferAttr,
    CFConsumedAttr,
    SwiftNewTypeAttr,
    FlagEnumAttr,
    ObjCBoxableAttr,
    SwiftNameAttr,
    SwiftAttrAttr,
    VisibilityAttr,
    UnavailableAttr,
    ObjCRootClassAttr,
    ObjCIndependentClassAttr,
    NSReturnsRetainedAttr,
    NonNullAttr,
    RestrictAttr,
    CFReturnsRetainedAttr,
    NotTailCalledAttr,
    ObjCCategoryDecl,
    ObjCTypeParamDecl,
    ObjCIvarDecl,
    NSConsumesSelfAttr,
    ObjCReturnsInnerPointerAttr,
    SentinelAttr,
    ObjCExceptionAttr,
    CFReturnsNotRetainedAttr,
    SwiftErrorAttr,
    NSConsumedAttr,
    SwiftAsyncAttr,
    ArcWeakrefUnavailableAttr,
    UnusedAttr,
    AlignedAttr,
    UsedAttr,
    WeakImportAttr,
    SwiftAsyncNameAttr,
    NSErrorDomainAttr,
    SwiftBridgedTypedefAttr,
    AllocSizeAttr,
    AllocAlignAttr,
    NoEscapeAttr,
    MaxFieldAlignmentAttr,
    WarnUnusedResultAttr,
    ObjCBridgeAttr,
    ObjCBridgeMutableAttr,
    ObjCDesignatedInitializerAttr,
    SwiftPrivateAttr,

    // Comments and Documentation
    FullComment,
    ParagraphComment,
    TextComment,
    BlockCommandComment,
    VerbatimLineComment,
    ParamCommandComment,
    InlineCommandComment,
};

// std attributes of the AST node.
id: []const u8 = &.{}, // Unique identifier for this node.
kind: Kind = .Unknown, // Kind of AST node, defined by the Kind enum.
loc: Loc = .{}, // Location information of this node.
range: Range = .{}, // Source range covered by this node.
isImplicit: bool = false, // Indicates if the node is implicitly generated by the compiler.
implicit: bool = false, // Redundant or alternative flag for implicitness.
isReferenced: bool = false, // True if this node is referenced elsewhere in the AST.
isUsed: bool = false, // True if this node is used in the AST.
renderKind: []const u8 = &.{},

// Extended properties for detailed AST analysis and code generation.
name: []const u8 = &.{}, // Name associated with this node, if applicable.
mangledName: []const u8 = &.{}, // Mangled name for linkage purposes, if applicable.
returnType: ?Type = null, // Return type of the node if it represents a function.
fixedUnderlyingType: ?Type = null, // Fixed underlying type information, typically used for typedefs.
type: ?Type = null, // General type information for variables, functions, etc.
tagUsed: []const u8 = &.{}, // Specific tag used in the definition of this node.
completeDefinition: bool = false, // Indicates if this node fully defines a type or entity.
inner: []const Self = &.{}, // Array of child nodes for hierarchical tree structures.
super: ?*Self = null, // Pointer to a superclass or parent node in a hierarchy.
implementation: ?*Self = null, // Implementation detail of this node, distinct from its declaration.
protocols: []const Self = &.{}, // Protocols or interfaces that this node implements (Objective-C).
getter: ?*Self = null, // Getter function if this node represents a property.
decl: ?*Self = null, // Declaration associated with this node.
ownedTagDecl: ?*Self = null, // Owned tag declaration specific to certain types of nodes.
size: ?u32 = null, // Size of the data type, if applicable.
cc: []const u8 = &.{}, // Calling convention used, if this node is a function.
storageClass: []const u8 = &.{}, // Storage class specifier (e.g., static, extern).
variadic: bool = false, // True if the function is variadic.
@"inline": bool = false, // True if the function is declared inline.
valueCategory: []const u8 = &.{}, // Category of the value (lvalue, rvalue, xvalue).
castKind: []const u8 = &.{}, // Type of cast, if this node represents a casting operation.
opcode: []const u8 = &.{}, // Operation code, if this node is an operator.
referencedDecl: ?*Self = null, // Reference to another declaration, if applicable.
value: ?std.json.Value = null, // Literal value, if this node is a literal expression.
isArrow: bool = false, // True if the access is via arrow (->) operator.
referencedMemberDecl: []const u8 = &.{}, // Referenced member declaration, for member access expressions.
isPartOfExplicitCast: bool = false, // True if this node is part of an explicit casting operation.
isBitfield: bool = false, // True if this field is declared as a bitfield.
previousDecl: []const u8 = &.{}, // Link to the previous declaration in a redeclaration chain.
inherited: bool = false, // True if this property or method is inherited.
message: []const u8 = &.{}, // Custom message associated with the node, often used for diagnostics.
hasElse: bool = false, // True if an 'if' statement has an 'else' branch.
isPostfix: bool = true, // True if the operator is postfix in unary operations.
canOverflow: bool = true, // True if the operation can result in an overflow.
argType: ?Type = null, // Argument type, if this node represents a function argument.
computeLHSType: ?Type = null, // Computed type of the left-hand side in assignments.
computeResultType: ?Type = null, // Computed result type of an expression.
visibility: []const u8 = &.{}, // Visibility specifier (public, private, protected).
qualifiers: []const u8 = &.{}, // Qualifiers applied to this node (const, volatile).
control: []const u8 = &.{}, // Control-specific information (e.g., loop control).
access: []const u8 = &.{}, // Access level for class members (public, private, protected).
instance: bool = false, // True if this node is an instance of a class or object.
readonly: bool = false, // True if the property is read-only.
copy: bool = false, // True if the property should be copied on assignment.
atomic: bool = false, // True if the property is atomic.
init: []const u8 = &.{}, // Initializer expression as a string, if applicable.
nrvo: bool = false, // Indicates Named Return Value Optimization.
class: bool = false, // True if this node represents a class.
interface: ?*Self = null, // Interface implemented by this node, if applicable.
retain: bool = false, // True if the property should be retained.
selector: []const u8 = &.{}, // Objective-C selector for methods.
receiverKind: []const u8 = &.{}, // Type of receiver (instance, class).
nullability: bool = false, // Indicates if the node supports nullability attributes.
strong: bool = false, // True if the property is strong (retains ownership).
assign: bool = false, // True if the property is assigned (does not retain ownership).
unsafe_unretained: bool = false, // True if the property is marked as unsafe_unretained.
variance: []const u8 = &.{}, // Variance type for generic or template parameters.
nonatomic: bool = false, // True if the property is nonatomic.
parentDeclContextId: []const u8 = &.{}, // Identifier of the parent declaration context.
readwrite: bool = false, // True if the property is read-write.
null_resettable: bool = false, // True if the property is null-resettable.
bounded: bool = false, // True if the type is bounded (has specified range or size).
weak: bool = false, // True if the property is weak (does not own the object).
text: []const u8 = &.{}, // Textual representation of the node.
direction: []const u8 = &.{}, // Direction for parameters (in, out, inout).
param: []const u8 = &.{}, // Parameter name, if this node represents a parameter.
paramIdx: ?u32 = null, // Index of the parameter in the function's parameter list.

pub fn gatherFramework(self: Self) ?[]const u8 {
    var path: ?[]const u8 = null;
    var index_to_end: ?usize = null;
    if (self.loc.includedFrom) |loc| {
        if (std.mem.indexOf(u8, loc.file, ".framework")) |index| {
            path = loc.file;
            index_to_end = index;
        }
    }
    if (path == null) {
        if (self.loc.spellingLoc) |loc| {
            if (std.mem.indexOf(u8, loc.file, ".framework")) |index| {
                path = loc.file;
                index_to_end = index;
            }
        }
    }

    if (path) |p| {
        const index = index_to_end.?; // If we have a path we have an index ot the end.
        var result = p[0..index];
        if (std.mem.lastIndexOf(u8, result, "/")) |start| {
            return result[start + 1 ..];
        }
    }

    return null;
}
