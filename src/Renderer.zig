const Renderer = @This();

const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;
const fmt = std.fmt;
const fs = std.fs;
const Dir = fs.Dir;
const File = fs.File;

const Framework = @import("main.zig").Framework;
const Analyzer = @import("Analyzer.zig");

allocator: Allocator,
frameworks: *const std.StringHashMap(Framework),
writer: File.Writer,
analyzer: *const Analyzer,

pub const Error = error{FrameworkNotFound} || File.WriteError || Analyzer.Type.Table.Error || File.OpenError;

pub const Options = struct {
    allocator: Allocator,
    output_dir: *Dir,
    frameworks: *const std.StringHashMap(Framework),
    analyzer: *const Analyzer,
};
pub fn run(options: Options) Error!void {
    const framework = options.frameworks.get(options.analyzer.framework).?;

    const output_path = try fmt.allocPrint(options.allocator, "{s}.zig", .{framework.output_file});
    var output_file = try options.output_dir.createFile(output_path, .{});
    defer output_file.close();

    var self = Renderer{
        .allocator = options.allocator,
        .frameworks = options.frameworks,
        .writer = output_file.writer(),
        .analyzer = options.analyzer,
    };

    try self.render("// THIS FILE IS AUTOGENERATED. MODIFICATIONS WILL NOT BE MAINTAINED.\n\n", .{});

    try self.render("const std = @import(\"std\");\n", .{});
    try self.render("const objc = @import(\"objc.zig\"); // Objective-C Runtime.\n", .{});
    for (framework.dependencies) |dependency| {
        const dep = self.frameworks.get(dependency).?;
        try self.render("const {s} = @import(\"{s}.zig\"); // Framework dependency {s}.\n", .{ dep.output_file, dep.output_file, dep.name });
    }
    try self.render("\n", .{});

    {
        var iter = self.analyzer.type_table.typedefs.iterator();
        while (iter.next()) |entry| {
            const named = entry.value_ptr;
            try self.renderNamed(named.*);
        }
    }
    {
        var iter = self.analyzer.type_table.protocols.iterator();
        while (iter.next()) |entry| {
            const named = entry.value_ptr;
            try self.renderNamed(named.*);
        }
    }
    {
        var iter = self.analyzer.type_table.interfaces.iterator();
        while (iter.next()) |entry| {
            const named = entry.value_ptr;
            try self.renderNamed(named.*);
        }
    }
}

fn renderNamed(self: *Renderer, named: Analyzer.Type.Table.Named) Error!void {
    switch (named.origin) {
        // Check to see if the decleration is part of a framework listed in the manifest.
        .framework => |f| {
            if (!mem.eql(u8, self.analyzer.framework, f)) {
                const framework = self.frameworks.get(self.analyzer.framework).?;
                var found = false;
                for (framework.dependencies) |dep| {
                    if (mem.eql(u8, dep, f)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    if (self.frameworks.contains(f)) {
                        std.debug.print(
                            "{s} depends on framework {s} but is not listed as a dependency to {s} in the manifest.\n",
                            .{
                                framework.name,
                                f,
                                framework.name,
                            },
                        );
                    }
                    // Let the user know that the framework is also not in the manifest to ease debugging.
                    else {
                        std.debug.print(
                            "{s} depends on framework {s} but is not listed as a dependency to {s} in the manifest. {s} is not listed in the manifest at all.\n",
                            .{
                                framework.name,
                                f,
                                framework.name,
                                f,
                            },
                        );
                    }

                    return error.FrameworkNotFound;
                }

                // Skip this decleration as it will be declared in another generated file and included in this one.
                return;
            }
        },
        else => {},
    }

    try self.renderType(named.type);
    try self.render("\n", .{});
}

fn render(self: *Renderer, comptime format: []const u8, args: anytype) Error!void {
    try self.writer.print(format, args);
}

fn renderParamName(self: *Renderer, name: []const u8) Error!void {
    var work = name;
    if (mem.eql(u8, name, "error")) {
        work = "@\"error\"";
    }
    _ = try self.writer.write(work);
}

fn renderMethod(self: *Renderer, method: Analyzer.Type.Method) Error!void {
    try self.render("\tpub fn ", .{});
    try self.renderMethodName(method.name);
    try self.render("(self: *@This()", .{});
    if (method.params.len > 0) {
        try self.render(", ", .{});
        for (method.params, 0..) |param, index| {
            try self.renderParamName(param.name);
            try self.render(": ", .{});
            try self.renderType(param.type);
            if (method.params.len > 4 or (method.params.len <= 4 and index < method.params.len - 1)) {
                try self.render(", ", .{});
            }
        }
    }
    try self.render(") ", .{});
    try self.renderType(method.return_type.*);
    try self.render(" {{\n", .{});
    try self.render("\t\treturn objc.msgSend(self, \"{s}\", ", .{method.name});
    try self.renderType(method.return_type.*);
    try self.render(", .{{", .{});
    for (method.params, 0..) |param, index| {
        try self.renderParamName(param.name);
        if (method.params.len > 4 or (method.params.len <= 4 and index < method.params.len - 1)) {
            try self.render(", ", .{});
        }
    }
    try self.render("}});\n\t}}\n", .{});
}

fn renderProtocol(self: *Renderer, protocol: Analyzer.Type.Protocol) Error!void {
    if (self.analyzer.type_table.lookupProtocol(protocol.name)) |named| {
        switch (named.origin) {
            .framework => |f| try self.render("// https://developer.apple.com/documentation/{s}/{s}?language=objc\n", .{ f, protocol.name }),
            else => {},
        }
    }
    try self.render("pub const ", .{});
    try self.renderNamedName(protocol.name);
    try self.render(" = opaque {{\n", .{});
    try self.render("\tpub const InternalInfo = objc.ExternProtocol(@This(), &.{{", .{});
    for (protocol.inherits) |inherit| {
        try self.renderNamedName(inherit.identifier.name);
        try self.render(", ", .{});
    }
    try self.render("}});\n", .{});
    try self.render("\tpub const as = InternalInfo.as;\n", .{});
    try self.render("\tpub const retain = InternalInfo.retain;\n", .{});
    try self.render("\tpub const release = InternalInfo.release;\n", .{});
    try self.render("\tpub const autorelease = InternalInfo.autorelease;\n", .{});

    if (protocol.children.len > 0) {
        try self.render("\n", .{});
        for (protocol.children) |child| {
            switch (child) {
                .method => |m| try self.renderMethod(m),
                else => {},
            }
        }
    }

    try self.render("}};\n", .{});
}

fn renderInterface(self: *Renderer, interface: Analyzer.Type.Interface) Error!void {
    if (self.analyzer.type_table.lookupInterface(interface.name)) |named| {
        switch (named.origin) {
            .framework => |f| try self.render("// https://developer.apple.com/documentation/{s}/{s}?language=objc\n", .{ f, interface.name }),
            else => {},
        }
    }
    try self.render("pub const ", .{});
    try self.renderNamedName(interface.name);
    try self.render(" = opaque {{\n", .{});
    try self.render("\tpub const InternalInfo = objc.ExternClass(\"{s}\", @This(), ", .{interface.name});
    try self.renderNamedName(interface.super.identifier.name);
    try self.render(", &.{{", .{});
    for (interface.protocols) |inherit| {
        try self.renderNamedName(inherit.identifier.name);
        try self.render(", ", .{});
    }
    try self.render("}});\n", .{});
    try self.render("\tpub const as = InternalInfo.as;\n", .{});
    try self.render("\tpub const retain = InternalInfo.retain;\n", .{});
    try self.render("\tpub const release = InternalInfo.release;\n", .{});
    try self.render("\tpub const autorelease = InternalInfo.autorelease;\n", .{});
    try self.render("\tpub const new = InternalInfo.new;\n", .{});
    try self.render("\tpub const alloc = InternalInfo.alloc;\n", .{});
    try self.render("\tpub const allocInit = InternalInfo.allocInit;\n", .{});

    if (interface.children.len > 0) {
        try self.render("\n", .{});
        for (interface.children) |child| {
            switch (child) {
                .method => |m| try self.renderMethod(m),
                else => {},
            }
        }
    }

    try self.render("}};\n", .{});
}

fn renderNamedName(self: *Renderer, name: []const u8) Error!void {
    if (name.len > 0) {
        const possible_named = try self.analyzer.type_table.lookup(name);
        if (possible_named == null) {
            try self.render("NOTFOUND", .{});
            // std.debug.print("Failed to find decleration {s}\n", .{name});
            return;
        }

        const named = possible_named.?;
        switch (named.origin) {
            .framework => |f| {
                const possible_framework = self.frameworks.get(f);
                if (possible_framework == null) {
                    return error.FrameworkNotFound;
                }
                const framework = possible_framework.?;
                var result = name;

                // Remove the prefix from the type if specified in the manifest.
                if (framework.remove_prefix.len > 0 and mem.startsWith(u8, result, framework.remove_prefix)) {
                    result = result[framework.remove_prefix.len..];
                }

                // If the framework that owns the decleration is not the one this generator is generating then
                // we need to append the import prefix.
                if (!mem.eql(u8, framework.name, self.analyzer.framework)) {
                    try self.render("{s}.{s}", .{ framework.output_file, result });
                } else {
                    _ = try self.writer.write(result);
                }
            },
            .runtime => {
                try self.render("objc.{s}", .{name});
            },
        }
    } else {
        _ = try self.writer.write("objc.Id");
    }
}

fn renderMethodName(self: *Renderer, name: []const u8) Error!void {
    const colon_count = mem.count(u8, name, ":");
    if (colon_count > 0) {
        var name_sub = name;
        var index: usize = 0;
        while (index < colon_count) : (index += 1) {
            const next_colon = mem.indexOf(u8, name_sub, ":").?;
            const current = name_sub[0..next_colon];
            if (index > 0) {
                // Capitalize the first letter of the word to match zig coding style.
                _ = try self.writer.writeByte(std.ascii.toUpper(current[0]));
                _ = try self.writer.write(current[1..]);
            } else {
                _ = try self.writer.write(current);
            }
            name_sub = name_sub[next_colon + 1 ..];
        }
    } else {
        _ = try self.writer.write(name);
    }
}

fn renderType(self: *Renderer, @"type": Analyzer.Type) Error!void {
    switch (@"type") {
        .void => try self.render("void", .{}),
        .pointer => |p| {
            if (p.nullable > 0) {
                try self.render("?", .{});
            }
            try self.render("*", .{});
            if (p.@"const" > 0) {
                try self.render("const ", .{});
            }
            try self.renderType(p.type.*);
        },
        .function => |f| {
            try self.render("fn(", .{});
            for (f.params, 0..) |param, index| {
                try self.renderType(param);
                if (index < f.params.len - 1) {
                    try self.render(", ", .{});
                }
            }
            try self.render(") ", .{});
            try self.renderType(f.return_type.*);
        },
        .identifier => |i| {
            if (i.nullable > 0) {
                try self.render("?", .{});
            }
            try self.renderNamedName(i.name);
            if (i.params.len > 0) {
                try self.render("(", .{});
                for (i.params, 0..) |p, index| {
                    try self.renderType(p);
                    if (index < i.params.len - 1) {
                        try self.render(", ", .{});
                    }
                }
                try self.render(")", .{});
            }
        },
        .instance_type => try self.render("*@This()", .{}),
        .protocol => |p| try self.renderProtocol(p),
        .interface => |i| try self.renderInterface(i),
        else => try self.render("UNIMPLEMENTED {}", .{std.meta.activeTag(@"type")}),
    }
}
