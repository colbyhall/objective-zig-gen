const Self = @This();

const std = @import("std");
const Framework = @import("main.zig").Framework;
const SemanticAnalyzer = @import("SemanticAnalyzer.zig");

allocator: std.mem.Allocator,
frameworks: *const std.StringHashMap(Framework),
writer: std.fs.File.Writer,
analyzer: *const SemanticAnalyzer,

pub const Options = struct {
    allocator: std.mem.Allocator,
    output_dir: *std.fs.Dir,
    frameworks: *const std.StringHashMap(Framework),
    analyzer: *const SemanticAnalyzer,
};
pub fn run(options: Options) !void {
    const framework = options.frameworks.get(options.analyzer.framework).?;

    const output_path = try std.fmt.allocPrint(options.allocator, "{s}.zig", .{framework.output_file});
    var output_file = try options.output_dir.createFile(output_path, .{});
    defer output_file.close();

    var self = Self{
        .allocator = options.allocator,
        .frameworks = options.frameworks,
        .writer = output_file.writer(),
        .analyzer = options.analyzer,
    };

    try self.print("// THIS FILE IS AUTOGENERATED. MODIFICATIONS WILL NOT BE MAINTAINED.\n", .{});

    var iter = self.analyzer.declerations.iterator();
    while (iter.next()) |entry| {
        const decl = entry.value_ptr;

        // Check to see if the decleration is part of a framework listed in the manifest.
        if (!std.mem.eql(u8, framework.name, decl.framework)) {
            var found = false;
            for (framework.dependencies) |dep| {
                if (std.mem.eql(u8, dep, decl.framework)) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                if (self.frameworks.contains(decl.framework)) {
                    std.debug.print(
                        "{s} depends on framework {s} but is not listed as a dependency to {s} in the manifest.\n",
                        .{
                            framework.name,
                            decl.framework,
                            framework.name,
                        },
                    );
                }
                // Let the user know that the framework is also not in the manifest to ease debugging.
                else {
                    std.debug.print(
                        "{s} depends on framework {s} but is not listed as a dependency to {s} in the manifest. {s} is not listed in the manifest at all.\n",
                        .{
                            framework.name,
                            decl.framework,
                            framework.name,
                            decl.framework,
                        },
                    );
                }
                return;
            }

            // Skip this decleration as it will be declared in another generated file and included in this one.
            continue;
        }

        // FOO
        switch (decl.type) {
            .protocol => |protocol| {
                try self.generateProtocol(decl.name, protocol);
            },
            .interface => |_| {},
        }
    }
}

fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {
    try self.writer.print(fmt, args);
}

fn generateProtocol(self: *Self, name: []const u8, protocol: SemanticAnalyzer.Protocol) !void {
    try self.print("pub const {s} = opaque {{\n", .{try self.resolveName(name)});
    try self.print("\t pub const InternalInfo = objc.ExternProtocol(@This(), &{{", .{});
    for (protocol.inherits) |inherit| {
        try self.print("{s}, ", .{try self.resolveName(inherit)});
    }
    try self.print("}});\n", .{});
    try self.print("\tpub const as = InternalInfo.as;\n", .{});
    try self.print("\tpub const retain = InternalInfo.retain;\n", .{});
    try self.print("\tpub const release = InternalInfo.release;\n", .{});
    try self.print("\tpub const autorelease = InternalInfo.autorelease;\n\n", .{});

    for (protocol.children) |child| {
        switch (child) {
            .method => |m| {
                try self.print("\tpub fn {s}(self: *@This(), ", .{try self.formatMethodName(m.name)});
                for (m.params) |param| {
                    try self.print("{s}: {s}, ", .{ param.name, try self.generateType(param.type) });
                }
                try self.print(") {s} {{\n", .{try self.generateType(m.return_type)});
                try self.print("\t\treturn objc.msgSend(self, \"{s}\", {s}, .{{", .{
                    m.name,
                    try self.generateType(m.return_type),
                });
                for (m.params) |param| {
                    try self.print("{s}, ", .{param.name});
                }
                try self.print("}});\n\t}}\n", .{});
            },
            else => {},
        }
    }
}

fn resolveName(self: *Self, name: []const u8) ![]const u8 {
    std.debug.print("{s}\n", .{name});
    const decl = self.analyzer.declerations.get(name).?;
    const framework = self.frameworks.get(decl.framework).?;
    var result = name;

    // Remove the prefix from the type if specified in the manifest.
    if (framework.remove_prefix.len > 0 and std.mem.startsWith(u8, result, framework.remove_prefix)) {
        result = result[framework.remove_prefix.len..];
    }

    // If the framework that owns the decleration is not the one this generator is generating then
    // we need to append the import prefix.
    if (!std.mem.eql(u8, framework.name, self.analyzer.framework)) {
        result = try std.fmt.allocPrint(
            self.allocator,
            "{s}.{s}",
            .{ framework.output_file, result },
        );
    }

    return result;
}

fn formatMethodName(self: *Self, name: []const u8) ![]const u8 {
    const colon_count = std.mem.count(u8, name, ":");
    const result = try self.allocator.alloc(u8, name.len - colon_count);

    if (colon_count > 0) {
        var name_sub = name;
        var current = result;
        var index: usize = 0;
        while (index < colon_count - 1) : (index += 1) {
            const next_colon = std.mem.indexOf(u8, name_sub, ":").?;
            std.mem.copyForwards(u8, current, result[0..next_colon]);
            if (index > 0) {
                current[0] = std.ascii.toUpper(current[0]);
            }
            current = current[next_colon..];
            name_sub = name_sub[next_colon..];
        }
    } else {
        std.mem.copyForwards(u8, result, name);
    }

    return result;
}

fn generateType(self: *Self, @"type": SemanticAnalyzer.Type) ![]const u8 {
    _ = self;
    switch (@"type") {
        .void => return "void",
        .uint64_t => return "u64",
        else => {},
    }
    return "TODO";
}
