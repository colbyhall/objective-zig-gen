const Self = @This();

const std = @import("std");
const Framework = @import("main.zig").Framework;
const SemanticAnalyzer = @import("SemanticAnalyzer.zig");

allocator: std.mem.Allocator,
frameworks: *const std.StringHashMap(Framework),
writer: std.fs.File.Writer,
analyzer: *const SemanticAnalyzer,

pub const Options = struct {
    allocator: std.mem.Allocator,
    output_dir: *std.fs.Dir,
    frameworks: *const std.StringHashMap(Framework),
    analyzer: *const SemanticAnalyzer,
};
pub fn run(options: Options) !void {
    const framework = options.frameworks.get(options.analyzer.framework).?;

    const output_path = try std.fmt.allocPrint(options.allocator, "{s}.zig", .{framework.output_file});
    var output_file = try options.output_dir.createFile(output_path, .{});
    defer output_file.close();

    var self = Self{
        .allocator = options.allocator,
        .frameworks = options.frameworks,
        .writer = output_file.writer(),
        .analyzer = options.analyzer,
    };

    try self.print("// THIS FILE IS AUTOGENERATED. MODIFICATIONS WILL NOT BE MAINTAINED.\n\n", .{});

    try self.print("const std = @import(\"std\");\n", .{});
    try self.print("// Objective C Runtime in zig. \nconst objc = @import(\"objc.zig\");\n", .{});
    for (framework.dependencies) |dependency| {
        const dep = self.frameworks.get(dependency).?;
        try self.print("// Framework dependency {s}. \nconst {s} = @import(\"{s}.zig\");\n", .{ dep.name, dep.output_file, dep.output_file });
    }
    try self.print("\n", .{});

    var iter = self.analyzer.declerations.iterator();
    while (iter.next()) |entry| {
        const decl = entry.value_ptr;

        // Check to see if the decleration is part of a framework listed in the manifest.
        if (!std.mem.eql(u8, framework.name, decl.framework)) {
            var found = false;
            for (framework.dependencies) |dep| {
                if (std.mem.eql(u8, dep, decl.framework)) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                if (self.frameworks.contains(decl.framework)) {
                    std.debug.print(
                        "{s} depends on framework {s} but is not listed as a dependency to {s} in the manifest.\n",
                        .{
                            framework.name,
                            decl.framework,
                            framework.name,
                        },
                    );
                }
                // Let the user know that the framework is also not in the manifest to ease debugging.
                else {
                    std.debug.print(
                        "{s} depends on framework {s} but is not listed as a dependency to {s} in the manifest. {s} is not listed in the manifest at all.\n",
                        .{
                            framework.name,
                            decl.framework,
                            framework.name,
                            decl.framework,
                        },
                    );
                }
                return;
            }

            // Skip this decleration as it will be declared in another generated file and included in this one.
            continue;
        }

        // FOO
        switch (decl.type) {
            .protocol => |protocol| {
                try self.printProtocol(decl.name, protocol);
            },
            .interface => |interface| {
                try self.printInterface(decl.name, interface);
            },
        }
    }
}

fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {
    try self.writer.print(fmt, args);
}

fn printMethod(self: *Self, method: SemanticAnalyzer.Method) !void {
    try self.print("\tpub fn ", .{});
    try self.printMethodName(method.name);
    try self.print("(self: *@This(), ", .{});
    for (method.params) |param| {
        try self.print("{s}: ", .{param.name});
        try self.printType(param.type);
        try self.print(", ", .{});
    }
    try self.print(") ", .{});
    try self.printType(method.return_type);
    try self.print(" {{\n", .{});
    try self.print("\t\treturn objc.msgSend(self, \"{s}\", ", .{method.name});
    try self.printType(method.return_type);
    try self.print(", .{{", .{});
    for (method.params) |param| {
        try self.print("{s}, ", .{param.name});
    }
    try self.print("}});\n\t}}\n", .{});
}

fn printProtocol(self: *Self, name: []const u8, protocol: SemanticAnalyzer.Protocol) !void {
    try self.print("pub const ", .{});
    try self.printDeclaredName(name);
    try self.print(" = opaque {{\n", .{});
    try self.print("\tpub const InternalInfo = objc.ExternProtocol(@This(), &.{{", .{});
    for (protocol.inherits) |inherit| {
        try self.printDeclaredName(inherit);
        try self.print(", ", .{});
    }
    try self.print("}});\n", .{});
    try self.print("\tpub const as = InternalInfo.as;\n", .{});
    try self.print("\tpub const retain = InternalInfo.retain;\n", .{});
    try self.print("\tpub const release = InternalInfo.release;\n", .{});
    try self.print("\tpub const autorelease = InternalInfo.autorelease;\n", .{});

    if (protocol.children.len > 0) {
        try self.print("\n", .{});
        for (protocol.children) |child| {
            switch (child) {
                .method => |m| try self.printMethod(m),
                else => {},
            }
        }
    }

    try self.print("}};\n\n", .{});
}

fn printInterface(self: *Self, name: []const u8, interface: SemanticAnalyzer.Interface) !void {
    try self.print("pub const ", .{});
    try self.printDeclaredName(name);
    try self.print(" = opaque {{\n", .{});
    try self.print("\tpub const InternalInfo = objc.ExternClass(\"{s}\", @This(), ", .{name});
    try self.printDeclaredName(interface.super);
    try self.print(", &.{{", .{});
    for (interface.protocols) |inherit| {
        try self.printDeclaredName(inherit);
        try self.print(", ", .{});
    }
    try self.print("}});\n", .{});
    try self.print("\tpub const as = InternalInfo.as;\n", .{});
    try self.print("\tpub const retain = InternalInfo.retain;\n", .{});
    try self.print("\tpub const release = InternalInfo.release;\n", .{});
    try self.print("\tpub const autorelease = InternalInfo.autorelease;\n", .{});
    try self.print("\tpub const new = InternalInfo.new;\n", .{});
    try self.print("\tpub const alloc = InternalInfo.alloc;\n", .{});
    try self.print("\tpub const allocInit = InternalInfo.allocInit;\n", .{});

    if (interface.children.len > 0) {
        try self.print("\n", .{});
        for (interface.children) |child| {
            switch (child) {
                .method => |m| try self.printMethod(m),
                else => {},
            }
        }
    }

    try self.print("}};\n\n", .{});
}

fn printDeclaredName(self: *Self, name: []const u8) !void {
    if (name.len > 0) {
        const possible_decl = self.analyzer.declerations.get(name);
        if (possible_decl == null) {
            try self.print("ERROR", .{});
            // std.debug.print("Failed to find decleration {s}\n", .{name});
            return;
        }
        const decl = possible_decl.?;
        const framework = self.frameworks.get(decl.framework).?;
        var result = name;

        // Remove the prefix from the type if specified in the manifest.
        if (framework.remove_prefix.len > 0 and std.mem.startsWith(u8, result, framework.remove_prefix)) {
            result = result[framework.remove_prefix.len..];
        }

        // If the framework that owns the decleration is not the one this generator is generating then
        // we need to append the import prefix.
        if (!std.mem.eql(u8, framework.name, self.analyzer.framework)) {
            try self.print("{s}.{s}", .{ framework.output_file, result });
        } else {
            _ = try self.writer.write(result);
        }
    } else {
        _ = try self.writer.write("objc.Id");
    }
}

fn printMethodName(self: *Self, name: []const u8) !void {
    const colon_count = std.mem.count(u8, name, ":");
    if (colon_count > 0) {
        var name_sub = name;
        var index: usize = 0;
        while (index < colon_count) : (index += 1) {
            const next_colon = std.mem.indexOf(u8, name_sub, ":").?;
            const current = name_sub[0..next_colon];
            if (index > 0) {
                // Capitalize the first letter of the word to match zig coding style.
                _ = try self.writer.writeByte(std.ascii.toUpper(current[0]));
                _ = try self.writer.write(current[1..]);
            } else {
                _ = try self.writer.write(current);
            }
            name_sub = name_sub[next_colon + 1 ..];
        }
    } else {
        _ = try self.writer.write(name);
    }
}

fn printType(self: *Self, @"type": SemanticAnalyzer.Type) !void {
    switch (@"type") {
        .void => try self.print("void", .{}),
        .uint64_t => try self.print("u64", .{}),
        .instance_type => try self.print("@This()*", .{}),
        .pointer => |p| {
            if (p.nullable > 0) {
                try self.print("?", .{});
            }
            try self.print("*", .{});
            if (p.@"const" > 0) {
                try self.print("const ", .{});
            }
            try self.printType(p.type.*);
        },
        .declared => |d| {
            if (d.nullable > 0) {
                try self.print("?", .{});
            }
            try self.printDeclaredName(d.name);
            if (d.params.len > 0) {
                try self.print("(", .{});
                for (d.params, 0..) |p, index| {
                    try self.printType(p);
                    if (index < d.params.len - 1) {
                        try self.print(", ", .{});
                    }
                }
                try self.print(")", .{});
            }
        },
        .function => |f| {
            try self.print("fn(", .{});
            for (f.params, 0..) |param, index| {
                try self.printType(param);
                if (index < f.params.len - 1) {
                    try self.print(", ", .{});
                }
            }
            try self.print(") ", .{});
            try self.printType(f.return_type.*);
        },
        else => try self.print("UNIMPLEMENTED", .{}),
    }
}
